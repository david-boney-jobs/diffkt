/*
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

package org.diffkt

import io.kotest.assertions.throwables.shouldThrow
import io.kotest.core.spec.style.AnnotationSpec
import io.kotest.matchers.ints.shouldBeExactly
import io.kotest.matchers.shouldBe
import testutils.shouldBeExactly
import testutils.shouldBeNear
import testutils.compareSparseWithDense

class SparseOpsTest: AnnotationSpec() {
    @Test
    fun testPlusSparseTensor() {
        val t1 = SparseFloatTensor(Shape(2, 2), listOf(Pair(intArrayOf(0, 0), 1f), Pair(intArrayOf(1, 1), 2f)))
        val t2 = SparseFloatTensor(Shape(2, 2), listOf(Pair(intArrayOf(0, 1), 1f), Pair(intArrayOf(1, 1), 2f)))
        val f = { x: DTensor, y: DTensor -> (x + y) }
        val out = f(t1, t2)
        val d1 = reverseDerivative(t1) { x: DTensor -> f(x, t2) }
        out shouldBeExactly tensorOf(1f, 1f, 0f, 4f).reshape(2, 2)
        assert(out is Sparse)
        d1 shouldBeExactly tensorOf(1f, 0f, 0f, 0f, 0f, 1f, 0f, 0f, 0f, 0f, 1f, 0f, 0f, 0f, 0f, 1f).reshape(2, 2, 2, 2)
    }

    @Test
    fun testPlusSparseVector() {
        val t1 = SparseFloatVector(Shape(3), floatArrayOf(1f, 2f), intArrayOf(0, 1))
        val t2 = SparseFloatVector(Shape(3), floatArrayOf(2f, 3f), intArrayOf(0, 1))
        val f = { x: DTensor, y: DTensor -> (x + y) }
        val out = f(t1, t2)
        val d1 = reverseDerivative(t1) { x: DTensor -> f(x, t2) }
        out shouldBeExactly tensorOf(3f, 5f, 0f)
        d1 shouldBeExactly tensorOf(1f, 0f, 0f, 0f, 1f, 0f, 0f, 0f, 1f).reshape(3, 3)
    }

    @Test
    fun testMatmulSparseTensor() {
        val t1 = SparseFloatTensor(Shape(2, 2), listOf(Pair(intArrayOf(0, 0), 1f), Pair(intArrayOf(1, 1), 2f)))
        val t2 = SparseFloatTensor(Shape(2, 2), listOf(Pair(intArrayOf(0, 1), 1f), Pair(intArrayOf(1, 1), 2f)))
        val f = { x: DTensor, y: DTensor -> (x.matmul(y)) }
        val out = f(t1, t2)
        val d1 = reverseDerivative(t1) { x: DTensor -> f(x, t2) }
        assert(out is Sparse)
        out shouldBeExactly tensorOf(0f, 1f, 0f, 4f).reshape(2, 2)
        d1 shouldBeExactly tensorOf(0.0F, 1.0F, 0.0F, 0.0F, 0.0F, 2.0F, 0.0F, 0.0F, 0.0F, 0.0F,
            0.0F, 1.0F, 0.0F, 0.0F, 0.0F, 2.0F).reshape(2, 2, 2, 2)
    }

    @Test
    // test generated by matmul3d.py -p 3 -k 3 -q 3
    fun `test matmul 3D sparse vs dense small 3by3by3 batch 2` () {
        //input left:
        val t1 = SparseFloatTensor(
            Shape(2, 3, 3), listOf(
            Pair(intArrayOf(0, 1, 1), 0.4236547993389047f),
            Pair(intArrayOf(0, 2, 2), 0.9636627605010293f),
            Pair(intArrayOf(1, 2, 1), 0.06022547162926983f)))
        //input right:
        val t2 = SparseFloatTensor(
            Shape(2, 3, 3), listOf(
            Pair(intArrayOf(0, 0, 0), 0.7781567509498505f),
            Pair(intArrayOf(1, 1, 0), 0.2532916025397821f),
            Pair(intArrayOf(1, 1, 2), 0.24442559200160274f),
            Pair(intArrayOf(1, 2, 1), 0.11037514116430513f)))
        compareSparseWithDense(Pair(t1, t2), { x, y -> x.matmul(y) })
    }

    @Test
    // test generated by matmul3d.py -p 5 -k 8 -q 1
    fun `test matmul 3D sparse vs dense 5by8by1 batch 2` () {
        //input left:
        val t1 = SparseFloatTensor(
            Shape(2, 5, 8), listOf(
            Pair(intArrayOf(0, 1, 4), 0.5680445610939323f),
            Pair(intArrayOf(0, 3, 2), 0.1433532874090464f),
            Pair(intArrayOf(0, 3, 4), 0.5218483217500717f),
            Pair(intArrayOf(0, 3, 6), 0.26455561210462697f),
            Pair(intArrayOf(0, 4, 0), 0.45615033221654855f),
            Pair(intArrayOf(1, 0, 4), 0.6778165367962301f),
            Pair(intArrayOf(1, 0, 7), 0.9621885451174382f),
            Pair(intArrayOf(1, 1, 0), 0.24875314351995803f),
            Pair(intArrayOf(1, 1, 3), 0.5722519057908734f),
            Pair(intArrayOf(1, 1, 5), 0.952749011516985f),
            Pair(intArrayOf(1, 1, 7), 0.8464086724711278f),
            Pair(intArrayOf(1, 2, 3), 0.39650574084698464f),
            Pair(intArrayOf(1, 2, 4), 0.8811031971111616f),
            Pair(intArrayOf(1, 3, 3), 0.6439901992296374f),
            Pair(intArrayOf(1, 3, 4), 0.4238550485581797f),
            Pair(intArrayOf(1, 3, 5), 0.6063932141279244f)))
        //input right:
        val t2 = SparseFloatTensor(
            Shape(2, 8, 1), listOf(
            Pair(intArrayOf(0, 1, 0), 0.41426299451466997f),
            Pair(intArrayOf(1, 0, 0), 0.3453516806969027f)))
        compareSparseWithDense(Pair(t1, t2), { x, y -> x.matmul(y) })
    }

    @Test
    // test generated by matmul3d.py -p 5 -k 8 -q 3
    fun `test matmul 3D sparse vs dense 5by8by3 batch 2` () {
        //input left:
        val t1 = SparseFloatTensor(
            Shape(2, 5, 8), listOf(
            Pair(intArrayOf(0, 1, 4), 0.5680445610939323f),
            Pair(intArrayOf(0, 3, 2), 0.1433532874090464f),
            Pair(intArrayOf(0, 3, 4), 0.5218483217500717f),
            Pair(intArrayOf(0, 3, 6), 0.26455561210462697f),
            Pair(intArrayOf(0, 4, 0), 0.45615033221654855f),
            Pair(intArrayOf(1, 1, 1), 0.6532008198571336f),
            Pair(intArrayOf(1, 2, 0), 0.8061939890460857f),
            Pair(intArrayOf(1, 3, 1), 0.6155595642838442f)))
        //input right:
        val t2 = SparseFloatTensor(
            Shape(2, 8, 3), listOf(
            Pair(intArrayOf(0, 1, 2), 0.2653894909394454f),
            Pair(intArrayOf(0, 2, 1), 0.09394051075844168f),
            Pair(intArrayOf(0, 3, 1), 0.31856895245132366f),
            Pair(intArrayOf(0, 4, 0), 0.13179786240439217f),
            Pair(intArrayOf(0, 4, 2), 0.2894060929472011f),
            Pair(intArrayOf(0, 6, 0), 0.8289400292173631f),
            Pair(intArrayOf(1, 2, 2), 0.32001715082246784f),
            Pair(intArrayOf(1, 6, 1), 0.21550767711355845f),
            Pair(intArrayOf(1, 7, 1), 0.25394164259502583f)))
        compareSparseWithDense(Pair(t1, t2), { x, y -> x.matmul(y) })
    }

    @Test
    // test generated by matmul3d.py -p 1 -k 1 -q 1
    fun `test matmul 3D sparse vs dense 1by1by1 batch 2` () {
        //input left:
        val t1 = SparseFloatTensor(
            Shape(2, 1, 1), listOf(
            )
        )
        //input right:
        val t2 = SparseFloatTensor(
            Shape(2, 1, 1), listOf(
                Pair(intArrayOf(1, 0, 0), 0.4375872112626925f)
            )
        )
        compareSparseWithDense(Pair(t1, t2), { x, y -> x.matmul(y) })
    }

    @Test
    // test generated by matmul3d.py -p 7 -k 1 -q 3 -b 1
    fun `test matmul 3D sparse vs dense 7by1by3 batch 1` () {
        //input left:
        val t1 = SparseFloatTensor(
            Shape(1, 7, 1), listOf(
                Pair(intArrayOf(0, 0, 0), 0.5488135039273248f),
                Pair(intArrayOf(0, 1, 0), 0.7151893663724195f),
                Pair(intArrayOf(0, 6, 0), 0.4375872112626925f)
            )
        )
        //input right:
        val t2 = SparseFloatTensor(
            Shape(1, 1, 3), listOf(
                Pair(intArrayOf(0, 0, 0), 0.07103605819788694f),
                Pair(intArrayOf(0, 0, 2), 0.02021839744032572f)
            )
        )
        compareSparseWithDense(Pair(t1, t2), { x, y -> x.matmul(y) })
    }

    @Test
    fun `test matmul 3D sparse vs dense 1by1by1 batch 1` () {
        //input left:
        val t1 = SparseFloatTensor(
            Shape(1, 1, 1), listOf(
                Pair(intArrayOf(0, 0, 0), 0.07103605819788694f),
            )
        )
        //input right:
        val t2 = SparseFloatTensor(
            Shape(1, 1, 1), listOf(
                Pair(intArrayOf(0, 0, 0), 0.07103605819788694f),
            )
        )
        compareSparseWithDense(Pair(t1, t2), { x, y -> x.matmul(y) })
    }

    @Test
    fun `test matmul 3D sparse vs dense 1by1by1 batch 1 empty to empty` () {
        //input left:
        val t1 = SparseFloatTensor(
            Shape(1, 1, 1), listOf(
            )
        )
        //input right:
        val t2 = SparseFloatTensor(
            Shape(1, 1, 1), listOf(
            )
        )
        compareSparseWithDense(Pair(t1, t2), { x, y -> x.matmul(y) })
    }

    @Test
    fun `test matmul 3D sparse vs dense 1by1by1 batch 1 non-empty to empty` () {
        //input left:
        val t1 = SparseFloatTensor(
            Shape(1, 1, 1), listOf(
                Pair(intArrayOf(0, 0, 0), 0.07103605819788694f),
            )
        )
        //input right:
        val t2 = SparseFloatTensor(
            Shape(1, 1, 1), listOf(
            )
        )
        compareSparseWithDense(Pair(t1, t2), { x, y -> x.matmul(y) })
    }

    @Test
    fun `test matmul 3D sparse vs dense 1by1by1 batch 1 empty to non-empty` () {
        //input left:
        val t1 = SparseFloatTensor(
            Shape(1, 1, 1), listOf(
            )
        )
        //input right:
        val t2 = SparseFloatTensor(
            Shape(1, 1, 1), listOf(
                Pair(intArrayOf(0, 0, 0), 0.07103605819788694f),
            )
        )
        compareSparseWithDense(Pair(t1, t2), { x, y -> x.matmul(y) })
    }

    @Test
    fun testTimesSparseTensor() {
        val t1 = SparseFloatTensor(Shape(2, 2), listOf(Pair(intArrayOf(0, 0), 1f), Pair(intArrayOf(1, 1), 2f)))
        val t2 = SparseFloatTensor(Shape(2, 2), listOf(Pair(intArrayOf(0, 1), 1f), Pair(intArrayOf(1, 1), 2f)))
        val f = { x: DTensor, y: DTensor -> (x.times(y)) }
        val out = f(t1, t2)
        val d1 = reverseDerivative(t1) { x: DTensor -> f(x, t2) }
        out shouldBeExactly  tensorOf(0f, 0f, 0f, 4f).reshape(2, 2)
        assert(out is Sparse)
        d1 shouldBeExactly tensorOf(0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 1.0F, 0.0F, 0.0F, 0.0F, 0.0F,
            0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 2.0F).reshape(2, 2, 2, 2)
    }

    @Test
    fun testMinusSparseTensor() {
        val t1 = SparseFloatTensor(Shape(2, 2), listOf(Pair(intArrayOf(0, 0), 1f), Pair(intArrayOf(1, 1), 2f)))
        val t2 = SparseFloatTensor(Shape(2, 2), listOf(Pair(intArrayOf(0, 1), 1f), Pair(intArrayOf(1, 1), 2f)))
        val f = { x: DTensor, y: DTensor -> (x - y) }
        val out = f(t1, t2)
        val d1 = reverseDerivative(t1) { x: DTensor -> f(x, t2) }
        out shouldBeExactly  tensorOf(1f, -1f, 0f, 0f).reshape(2, 2)
        assert(out is Sparse)
        d1 shouldBeExactly tensorOf(1f, 0f, 0f, 0f, 0f, 1f, 0f, 0f, 0f, 0f, 1f, 0f, 0f, 0f, 0f, 1f).reshape(2, 2, 2, 2)
    }

    /**
     * Given [t1] and [t2] as identically-sized square sparse floating point tensors,
     * test the matmul, minus, times, and + operations by comparing sparse results with dense results
     */
    fun compareAll(t1: SparseFloatTensor, t2: SparseFloatTensor) {
        compareSparseWithDense(Pair(t1, t2), { x, y -> x.matmul(y) })
        compareSparseWithDense(Pair(t1, t2), { x, y -> x.minus(y) })
        compareSparseWithDense(Pair(t1, t2), { x, y -> x.times(y) })
        compareSparseWithDense(Pair(t1, t2), { x, y -> x+y })
    }

    @Test
    fun `testAll for two identical diagonal tensors`() {
        val t1 = SparseFloatTensor(Shape(2, 2), listOf(Pair(intArrayOf(0, 0), 1f), Pair(intArrayOf(1, 1), 2f)))
        val t2 = SparseFloatTensor(Shape(2, 2), listOf(Pair(intArrayOf(0, 0), 1f), Pair(intArrayOf(1, 1), 2f)))

        compareAll(t1, t2)
    }

    // Note: MKL doesn't support matdiv, so it's ignored in the test for now
    @Ignore
    fun `sparse matdiv for two identical diagonal tensors`() {
        val t1 = SparseFloatTensor(Shape(2, 2), listOf(Pair(intArrayOf(0, 0), 1f), Pair(intArrayOf(1, 1), 2f)))
        val t2 = SparseFloatTensor(Shape(2, 2), listOf(Pair(intArrayOf(0, 0), 1f), Pair(intArrayOf(1, 1), 2f)))

        // compare sparse results with numpy
        val outExp = SparseFloatTensor(Shape(2, 2), listOf(Pair(intArrayOf(0, 0), 1f), Pair(intArrayOf(1, 1), 1f)))
        val f = { x: DTensor, y: DTensor -> x.matdiv(y) }
        val out = f(t1, t2)
        out.shouldBeNear(outExp, 1e-6f)
        assert(out is Sparse)
    }

    @Test
    fun `testAll for same-sized differing content square tensors`() {
        val t1 = SparseFloatTensor(Shape(2, 2), listOf(Pair(intArrayOf(0, 0), 1f), Pair(intArrayOf(1, 1), 2f)))
        val t2 = SparseFloatTensor(Shape(2, 2), listOf(Pair(intArrayOf(0, 1), 1f), Pair(intArrayOf(1, 1), 2f)))
        compareAll(t1, t2)
    }

    @Test
    fun `test matmul with non-matching outer dimensions`() {
        val t1 = SparseFloatTensor(Shape(8, 2), listOf(Pair(intArrayOf(0, 0), 1f), Pair(intArrayOf(1, 1), 2f)))
        val t2 = SparseFloatTensor(Shape(2, 7), listOf(Pair(intArrayOf(0, 1), 1f), Pair(intArrayOf(1, 1), 2f)))
        compareSparseWithDense(Pair(t1, t2), { x, y -> x.matmul(y) })
    }

    @Ignore
    fun `test matrix div non-square tensor divided by square tensor`() {
        // input left
        val t1 = SparseFloatTensor(
            Shape(5, 9), listOf(
            Pair(intArrayOf(0, 8), 0.38877912391436853f),
            Pair(intArrayOf(3, 3), 0.7800433424910276f)))
        // input right
        val t2 = SparseFloatTensor(
            Shape(9, 9), listOf(
            Pair(intArrayOf(0, 0), 0.22329107915353885f),
            Pair(intArrayOf(0, 4), 0.36072883534777267f),
            Pair(intArrayOf(0, 5), 0.22308094169128878f),
            Pair(intArrayOf(0, 6), 0.6887261618213565f),
            Pair(intArrayOf(1, 0), 0.941010860245836f),
            Pair(intArrayOf(1, 2), 0.07799233938998706f),
            Pair(intArrayOf(1, 6), 0.2934872561021975f),
            Pair(intArrayOf(1, 8), 0.46426408804015173f),
            Pair(intArrayOf(2, 0), 0.21506214371433952f),
            Pair(intArrayOf(2, 2), 0.12087875153895689f),
            Pair(intArrayOf(2, 3), 0.917687007744725f),
            Pair(intArrayOf(2, 7), 0.04321572973662613f),
            Pair(intArrayOf(2, 8), 0.7524449169599731f),
            Pair(intArrayOf(3, 7), 0.44335096201326485f),
            Pair(intArrayOf(3, 8), 0.4679961473799611f),
            Pair(intArrayOf(4, 8), 0.3406742720441993f),
            Pair(intArrayOf(5, 2), 0.27149077328868065f),
            Pair(intArrayOf(5, 4), 0.21542897828136154f),
            Pair(intArrayOf(5, 6), 0.018399946630616282f),
            Pair(intArrayOf(6, 0), 0.7423517360658496f),
            Pair(intArrayOf(6, 2), 0.420103554589757f),
            Pair(intArrayOf(6, 4), 0.9720455259033695f),
            Pair(intArrayOf(7, 1), 0.6756664492813946f),
            Pair(intArrayOf(7, 8), 0.19916263217137087f),
            Pair(intArrayOf(8, 1), 0.39386732248283196f),
            Pair(intArrayOf(8, 2), 0.33918540311781975f),
            Pair(intArrayOf(8, 5), 0.4072471068550777f)))
        // expected output
        val outExp = SparseFloatTensor(
            Shape(5, 9), listOf(
            Pair(intArrayOf(0, 4), 1.1412048276540474f),
            Pair(intArrayOf(3, 0), 0.1073318494237487f),
            Pair(intArrayOf(3, 1), -0.23509817372107958f),
            Pair(intArrayOf(3, 2), 0.8500102277878319f),
            Pair(intArrayOf(3, 3), -0.08285492854382911f),
            Pair(intArrayOf(3, 4), -1.4632403080983682f),
            Pair(intArrayOf(3, 5), -0.2676059269963153f),
            Pair(intArrayOf(3, 6), 0.019476843308245978f),
            Pair(intArrayOf(3, 7), 0.03427288554210957f),
            Pair(intArrayOf(3, 8), -0.058794008944152015f)))

        val f = { x: DTensor, y: DTensor -> x.matdiv(y) }
        val out = f(t1, t2)
        out.shouldBeNear(outExp, 1e-6f)
        assert(out is Sparse)
    }

    @Test
    fun `testAll with both 9by9 inputs`() {
        // input left
        val t1 = SparseFloatTensor(
            Shape(9, 9), listOf(
            Pair(intArrayOf(0, 3), 0.5678649545949946f),
            Pair(intArrayOf(0, 5), 0.6264006261919175f),
            Pair(intArrayOf(0, 6), 0.4956239121885867f),
            Pair(intArrayOf(0, 7), 0.1854445319921587f),
            Pair(intArrayOf(0, 8), 0.38877912391436853f),
            Pair(intArrayOf(1, 0), 0.5727042902682571f),
            Pair(intArrayOf(1, 3), 0.19178860193593794f),
            Pair(intArrayOf(1, 5), 0.4153338145563784f),
            Pair(intArrayOf(1, 6), 0.6365081754393465f),
            Pair(intArrayOf(1, 7), 0.005970365451990145f),
            Pair(intArrayOf(2, 2), 0.35634256423348254f),
            Pair(intArrayOf(2, 3), 0.22042364138234116f),
            Pair(intArrayOf(3, 6), 0.20979241153998585f),
            Pair(intArrayOf(3, 7), 0.8287415038352453f),
            Pair(intArrayOf(5, 1), 0.6984641963412034f),
            Pair(intArrayOf(5, 2), 0.05974170895963615f),
            Pair(intArrayOf(5, 6), 0.552216901543784f),
            Pair(intArrayOf(5, 7), 0.24070623413629832f),
            Pair(intArrayOf(6, 0), 0.025207974983498915f),
            Pair(intArrayOf(6, 4), 0.8846354387701332f),
            Pair(intArrayOf(7, 5), 0.13073848426080437f),
            Pair(intArrayOf(7, 6), 0.5411990852645557f),
            Pair(intArrayOf(8, 4), 0.27647797964142207f),
            Pair(intArrayOf(8, 5), 0.5011804871957674f),
            Pair(intArrayOf(8, 7), 0.04214445837531333f),
            Pair(intArrayOf(8, 8), 0.3155458416589393f)))
        // input right
        val t2 = SparseFloatTensor(
            Shape(9, 9), listOf(
            Pair(intArrayOf(0, 0), 0.22329107915353885f),
            Pair(intArrayOf(0, 4), 0.36072883534777267f),
            Pair(intArrayOf(0, 5), 0.22308094169128878f),
            Pair(intArrayOf(0, 6), 0.6887261618213565f),
            Pair(intArrayOf(1, 0), 0.941010860245836f),
            Pair(intArrayOf(1, 2), 0.07799233938998706f),
            Pair(intArrayOf(1, 6), 0.2934872561021975f),
            Pair(intArrayOf(1, 8), 0.46426408804015173f),
            Pair(intArrayOf(2, 0), 0.21506214371433952f),
            Pair(intArrayOf(2, 2), 0.12087875153895689f),
            Pair(intArrayOf(2, 3), 0.917687007744725f),
            Pair(intArrayOf(2, 7), 0.04321572973662613f),
            Pair(intArrayOf(2, 8), 0.7524449169599731f),
            Pair(intArrayOf(3, 7), 0.44335096201326485f),
            Pair(intArrayOf(3, 8), 0.4679961473799611f),
            Pair(intArrayOf(4, 8), 0.3406742720441993f),
            Pair(intArrayOf(5, 2), 0.27149077328868065f),
            Pair(intArrayOf(5, 4), 0.21542897828136154f),
            Pair(intArrayOf(5, 6), 0.018399946630616282f),
            Pair(intArrayOf(6, 0), 0.7423517360658496f),
            Pair(intArrayOf(6, 2), 0.420103554589757f),
            Pair(intArrayOf(6, 4), 0.9720455259033695f),
            Pair(intArrayOf(7, 1), 0.6756664492813946f),
            Pair(intArrayOf(7, 8), 0.19916263217137087f),
            Pair(intArrayOf(8, 1), 0.39386732248283196f),
            Pair(intArrayOf(8, 2), 0.33918540311781975f),
            Pair(intArrayOf(8, 5), 0.4072471068550777f)))

        compareAll(t1, t2)
    }

    @Ignore
    fun `matdiv with both 9by9 inputs`() {
        // input left
        val t1 = SparseFloatTensor(
            Shape(9, 9), listOf(
            Pair(intArrayOf(0, 3), 0.5678649545949946f),
            Pair(intArrayOf(0, 5), 0.6264006261919175f),
            Pair(intArrayOf(0, 6), 0.4956239121885867f),
            Pair(intArrayOf(0, 7), 0.1854445319921587f),
            Pair(intArrayOf(0, 8), 0.38877912391436853f),
            Pair(intArrayOf(1, 0), 0.5727042902682571f),
            Pair(intArrayOf(1, 3), 0.19178860193593794f),
            Pair(intArrayOf(1, 5), 0.4153338145563784f),
            Pair(intArrayOf(1, 6), 0.6365081754393465f),
            Pair(intArrayOf(1, 7), 0.005970365451990145f),
            Pair(intArrayOf(2, 2), 0.35634256423348254f),
            Pair(intArrayOf(2, 3), 0.22042364138234116f),
            Pair(intArrayOf(3, 6), 0.20979241153998585f),
            Pair(intArrayOf(3, 7), 0.8287415038352453f),
            Pair(intArrayOf(5, 1), 0.6984641963412034f),
            Pair(intArrayOf(5, 2), 0.05974170895963615f),
            Pair(intArrayOf(5, 6), 0.552216901543784f),
            Pair(intArrayOf(5, 7), 0.24070623413629832f),
            Pair(intArrayOf(6, 0), 0.025207974983498915f),
            Pair(intArrayOf(6, 4), 0.8846354387701332f),
            Pair(intArrayOf(7, 5), 0.13073848426080437f),
            Pair(intArrayOf(7, 6), 0.5411990852645557f),
            Pair(intArrayOf(8, 4), 0.27647797964142207f),
            Pair(intArrayOf(8, 5), 0.5011804871957674f),
            Pair(intArrayOf(8, 7), 0.04214445837531333f),
            Pair(intArrayOf(8, 8), 0.3155458416589393f)))
        // input right
        val t2 = SparseFloatTensor(
            Shape(9, 9), listOf(
            Pair(intArrayOf(0, 0), 0.22329107915353885f),
            Pair(intArrayOf(0, 4), 0.36072883534777267f),
            Pair(intArrayOf(0, 5), 0.22308094169128878f),
            Pair(intArrayOf(0, 6), 0.6887261618213565f),
            Pair(intArrayOf(1, 0), 0.941010860245836f),
            Pair(intArrayOf(1, 2), 0.07799233938998706f),
            Pair(intArrayOf(1, 6), 0.2934872561021975f),
            Pair(intArrayOf(1, 8), 0.46426408804015173f),
            Pair(intArrayOf(2, 0), 0.21506214371433952f),
            Pair(intArrayOf(2, 2), 0.12087875153895689f),
            Pair(intArrayOf(2, 3), 0.917687007744725f),
            Pair(intArrayOf(2, 7), 0.04321572973662613f),
            Pair(intArrayOf(2, 8), 0.7524449169599731f),
            Pair(intArrayOf(3, 7), 0.44335096201326485f),
            Pair(intArrayOf(3, 8), 0.4679961473799611f),
            Pair(intArrayOf(4, 8), 0.3406742720441993f),
            Pair(intArrayOf(5, 2), 0.27149077328868065f),
            Pair(intArrayOf(5, 4), 0.21542897828136154f),
            Pair(intArrayOf(5, 6), 0.018399946630616282f),
            Pair(intArrayOf(6, 0), 0.7423517360658496f),
            Pair(intArrayOf(6, 2), 0.420103554589757f),
            Pair(intArrayOf(6, 4), 0.9720455259033695f),
            Pair(intArrayOf(7, 1), 0.6756664492813946f),
            Pair(intArrayOf(7, 8), 0.19916263217137087f),
            Pair(intArrayOf(8, 1), 0.39386732248283196f),
            Pair(intArrayOf(8, 2), 0.33918540311781975f),
            Pair(intArrayOf(8, 5), 0.4072471068550777f)))
        // expected output
        val outExp = SparseFloatTensor(
            Shape(9, 9), listOf(
            Pair(intArrayOf(0, 0), 0.9059784554711483f),
            Pair(intArrayOf(0, 1), -0.34595459132886885f),
            Pair(intArrayOf(0, 2), 0.6188002552096269f),
            Pair(intArrayOf(0, 3), 0.35796161731868736f),
            Pair(intArrayOf(0, 4), 0.1092351580394686f),
            Pair(intArrayOf(0, 5), -1.457280770109116f),
            Pair(intArrayOf(0, 6), -0.013242225158781595f),
            Pair(intArrayOf(0, 7), -0.6073325820616003f),
            Pair(intArrayOf(0, 8), 1.0418590876432745f),
            Pair(intArrayOf(1, 0), 0.75233076177222f),
            Pair(intArrayOf(1, 1), 0.45588364749947674f),
            Pair(intArrayOf(1, 2), 0.2089913013013781f),
            Pair(intArrayOf(1, 3), -0.006905017479728437f),
            Pair(intArrayOf(1, 4), -0.8662673908474214f),
            Pair(intArrayOf(1, 5), -0.8390102239192025f),
            Pair(intArrayOf(1, 6), -0.09324695373668745f),
            Pair(intArrayOf(1, 7), -0.3542748611619327f),
            Pair(intArrayOf(1, 8), 0.6077468828894173f),
            Pair(intArrayOf(2, 0), -0.12600874931922013f),
            Pair(intArrayOf(2, 1), 0.20132202151985548f),
            Pair(intArrayOf(2, 2), 0.24019479356479773f),
            Pair(intArrayOf(2, 3), -0.023413038816255987f),
            Pair(intArrayOf(2, 4), -0.7491879800305157f),
            Pair(intArrayOf(2, 5), 1.5054432027338018f),
            Pair(intArrayOf(2, 6), -0.28688070075817956f),
            Pair(intArrayOf(2, 7), -0.04023673742610865f),
            Pair(intArrayOf(2, 8), 0.06902480087962026f),
            Pair(intArrayOf(3, 0), 0.25352943521785826f),
            Pair(intArrayOf(3, 1), 0.09194258243841574f),
            Pair(intArrayOf(3, 3), 1.8692674085377303f),
            Pair(intArrayOf(3, 4), -2.740503535591017f),
            Pair(intArrayOf(3, 5), 0.4454404482464987f),
            Pair(intArrayOf(3, 6), -0.1928059474058856f),
            Pair(intArrayOf(3, 7), 0.08095626192438211f),
            Pair(intArrayOf(3, 8), -0.13887780711720785f),
            Pair(intArrayOf(5, 0), 0.6411312440866531f),
            Pair(intArrayOf(5, 1), 0.2869017551565289f),
            Pair(intArrayOf(5, 3), 0.5429248039594792f),
            Pair(intArrayOf(5, 4), -1.8608417112071853f),
            Pair(intArrayOf(5, 5), 1.4375602396816316f),
            Pair(intArrayOf(5, 6), -0.5565239962749926f),
            Pair(intArrayOf(5, 7), 1.2384652400949965f),
            Pair(intArrayOf(5, 8), -0.35119748985584437f),
            Pair(intArrayOf(6, 0), 0.3892239016683549f),
            Pair(intArrayOf(6, 1), -0.849036578749672f),
            Pair(intArrayOf(6, 4), 1.084390966622367f),
            Pair(intArrayOf(6, 5), -1.0264849369787539f),
            Pair(intArrayOf(6, 6), 0.9931281298056186f),
            Pair(intArrayOf(6, 7), 0.12428581361220088f),
            Pair(intArrayOf(6, 8), -0.21320822923324742f),
            Pair(intArrayOf(7, 0), 0.7017997832133478f),
            Pair(intArrayOf(7, 1), 0.15536431409884194f),
            Pair(intArrayOf(7, 4), -0.2333336036369965f),
            Pair(intArrayOf(7, 5), 0.6659675818574476f),
            Pair(intArrayOf(7, 6), -0.4080345247259106f),
            Pair(intArrayOf(7, 7), 0.036958157678230574f),
            Pair(intArrayOf(7, 8), -0.06340050505591377f),
            Pair(intArrayOf(8, 0), 0.3074633356286053f),
            Pair(intArrayOf(8, 1), -0.5858062323841562f),
            Pair(intArrayOf(8, 3), 0.09505890814792546f),
            Pair(intArrayOf(8, 4), 1.9559761584992423f),
            Pair(intArrayOf(8, 5), -2.164755153800923f),
            Pair(intArrayOf(8, 6), 0.6500910326122288f),
            Pair(intArrayOf(8, 7), -0.6192091230687915f),
            Pair(intArrayOf(8, 8), 1.0622329034792495f)))

        val f = { x: DTensor, y: DTensor -> x.matdiv(y) }
        val out = f(t1, t2)
        out.shouldBeNear(outExp, 1e-6f)
        assert(out is Sparse)
    }

    @Ignore
    fun  `test mat div by a singular tensor`() {
        // input left
        val t1 = SparseFloatTensor(
            Shape(2, 2), listOf(
                Pair(intArrayOf(0, 1), 0.3834415188257777f)
            )
        )
        // input right
        val t2 = SparseFloatTensor(
            Shape(2, 2), listOf(
                Pair(intArrayOf(1, 1), 0.5448831829968969f)
            )
        )

        val f = { x: DTensor, y: DTensor -> x.matdiv(y) }

        shouldThrow<java.lang.Error> { f(t1, t2) }
    }

    @Test
    fun `test SparseFloatTensor constructor 2D`() {
        val t1 = SparseFloatTensor(Shape(2, 2), listOf(Pair(intArrayOf(0, 0), 1f), Pair(intArrayOf(1, 1), 2f)))
        t1.shape shouldBe Shape(2, 2)
        t1.dims.size shouldBeExactly 1
        t1.dims[0].outer.shouldBe(intArrayOf(0, 1, 2))
        t1.dims[0].inner.shouldBe(intArrayOf(0, 1))
        t1.values.shouldBe(floatArrayOf(1f, 2f))
    }

    @Test
    fun `test SparseFloatTensor constructor with unordered input 2D`() {
        val t1 = SparseFloatTensor(Shape(2, 2), listOf(Pair(intArrayOf(1, 1), 2f), Pair(intArrayOf(0, 0), 1f)))
        t1.shape shouldBe Shape(2, 2)
        t1.dims.size shouldBeExactly 1
        t1.dims[0].outer.shouldBe(intArrayOf(0, 1, 2))
        t1.dims[0].inner.shouldBe(intArrayOf(0, 1))
        t1.values.shouldBe(floatArrayOf(1f, 2f))
    }

    @Test
    //a test generated from ./sparseFloatTensorInvoke2D.py -r 9 -c 7 -z 0.1 -p -s 3
    fun `test SparseFloatTensor constructor with unordered input 2D 9 by 7`() {
        //input:
        val t1 = SparseFloatTensor(
            Shape(9, 7), listOf(
            Pair(intArrayOf(5, 5), 0.39690000290173266f),
            Pair(intArrayOf(7, 5), 0.4977941146173057f),
            Pair(intArrayOf(8, 5), 0.40482521731090604f),
            Pair(intArrayOf(8, 4), 0.904667588743367f),
            Pair(intArrayOf(5, 6), 0.6239161135482231f),
            Pair(intArrayOf(3, 5), 0.6007427213777693f),
            Pair(intArrayOf(8, 0), 0.9183830391397627f)))
        //expected output:
        val shapeExp = Shape(9, 7)
        val valuesExp = floatArrayOf(
            0.6007427213777693f,0.39690000290173266f,0.6239161135482231f,0.4977941146173057f,0.40482521731090604f,
            0.904667588743367f,0.9183830391397627f
        )
        val innerExp = intArrayOf(
            5,5,6,5,5,
            4,0
        )
        val outerExp = intArrayOf(
            0,0,0,0,1,
            1,3,3,4,7
        )

        t1 shouldBe SparseFloatTensor(shapeExp, valuesExp, listOf(DimData(innerExp, outerExp)))
    }

    @Test
    fun `test SparseEigen2D constructor`() {
        val e = SparseEigen2D(intArrayOf(2, 2), floatArrayOf(1f, 2f), intArrayOf(0, 1), intArrayOf(0, 1, 2))
        e.shape.shouldBe(intArrayOf(2, 2))
        e.inner.shouldBe(intArrayOf(0, 1))
        e.outer.shouldBe(intArrayOf(0, 1, 2))
        e.values.shouldBe(floatArrayOf(1f, 2f))
    }

    @Test
    fun `test transpose`() {
        val t1 = SparseFloatTensor(
                Shape(8, 2),
                listOf(Pair(intArrayOf(0, 0), 1f), Pair(intArrayOf(0, 1), 3f), Pair(intArrayOf(1, 1), 2f))
        )
        compareSparseWithDense(t1, {x: DTensor -> x.transpose()})
    }

    @Test
    fun `test transpose empty 2D`() {
        val t1 = SparseFloatTensor(
            Shape(8, 2),
            listOf()
        )
        compareSparseWithDense(t1, {x: DTensor -> x.transpose()})
    }

    @Test
    fun `test sum all axes`() {
        val t1 = SparseFloatTensor(Shape(2, 2), listOf(Pair(intArrayOf(0, 0), 1f), Pair(intArrayOf(0, 1), 2f)))
        compareSparseWithDense(t1, {x: DTensor -> x.sum(keepDims = true)})
        compareSparseWithDense(t1, {x: DTensor -> x.sum(intArrayOf(1), keepDims = true)})
        compareSparseWithDense(t1, {x: DTensor -> x.sum(intArrayOf(0), keepDims = true)})
    }

    @Test
    fun `test relu`() {
        val t1 = SparseFloatTensor(Shape(2, 2), listOf(Pair(intArrayOf(0, 0), -1f), Pair(intArrayOf(0, 1), 2f)))
        compareSparseWithDense(t1, {x: DTensor -> x.relu()})
    }

    @Test
    fun `test times dense`() {
        val t1 = SparseFloatTensor(Shape(2, 2), listOf(Pair(intArrayOf(0, 0), -1f), Pair(intArrayOf(0, 1), 2f)))
        val t2 = FloatTensor(Shape(2, 2)) { 2f }
        val res = t1.times(t2)
        val res2 = t2.times(t1)
        assert(res is SparseFloatTensor)
        assert(res2 is SparseFloatTensor)
        res shouldBeExactly tensorOf(-2f, 4f, 0f, 0f).reshape(2, 2)
        res2 shouldBeExactly tensorOf(-2f, 4f, 0f, 0f).reshape(2, 2)
    }
}
